<html>
<head>
    <script src="gpu-browser.min.js"></script>
    <script src="MyLib.js"></script>
    <script src="ins.js"></script>
    <script src="drums.js"></script>
</head>
<body>
	<img src="const.png" style="position:fixed;bottom:0;right:0;z-index:10">
	<table style="width:100%;height:100%">
		<tr>
			<td style="width:100%;position:relative;">
			</td>
			<td id="xy" style="position:relative">
				<div id="ab">HALLO</div>
			</td>
			<td id="xyz" style="width:auto">
			
			
			
			
			
			<script type="module">

			import * as THREE from './three.module.js';

			import Stats from './stats.module.js';

			let camera, scene, renderer, stats;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 400;

				scene = new THREE.Scene();

				let object;

				const ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.8 );
				camera.add( pointLight );
				scene.add( camera );

				const map = new THREE.TextureLoader().load( 'textures/uv_grid_opengl.jpg' );
				map.wrapS = map.wrapT = THREE.RepeatWrapping;
				map.anisotropy = 16;

				const material = new THREE.MeshPhongMaterial( { map: map, side: THREE.DoubleSide } );


	function fractal(hmap,x0,x1,y0,y1,amp,decay) {
		let xx = Math.round((x0 + x1) / 2);
		let yy = Math.round((y0 + y1) / 2);

		if(hmap[x0][yy] == null) hmap[x0][yy] = (hmap[x0][y0] + hmap[x0][y1]) / 2 + amp * Math.random();
		if(hmap[x1][yy] == null) hmap[x1][yy] = (hmap[x1][y0] + hmap[x1][y1]) / 2 + amp * Math.random();
		if(hmap[xx][y0] == null) hmap[xx][y0] = (hmap[x0][y0] + hmap[x1][y0]) / 2 + amp * Math.random();
		if(hmap[xx][y1] == null) hmap[xx][y1] = (hmap[x0][y1] + hmap[x1][y1]) / 2 + amp * Math.random();
		if(hmap[xx][yy] == null) hmap[xx][yy] = (hmap[x0][y0] + hmap[x1][y0] + hmap[x0][y1] + hmap[x1][y1]) / 4 + amp * Math.random();

				if(x0 != xx && x1 != xx && y0 != yy && y1 != yy) {
			fractal(hmap,x0,xx,y0,yy,-amp * decay,decay);
			fractal(hmap,xx,x1,y0,yy,-amp * decay,decay);
			fractal(hmap,x0,xx,yy,y1,-amp * decay,decay);
			fractal(hmap,xx,x1,yy,y1,-amp * decay,decay);
		}
	}

	function doener(width,decay) {
		let hmap = [];
		for(let y = 0;y < width;++y) {
			let xs = [];
			for(let x = 0;x < width;++x) {
				xs.push(null);
			}
			hmap.push(xs);
		}
		let len = 50;
		hmap[0][0] = len;
		hmap[width - 1][width - 1] = len;
		hmap[width - 1][0] = len;
		hmap[0][width - 1] = len;
		fractal(hmap,0,width - 1,0,width - 1,50.0,decay);
		for(let i = 1;i < width - 1;++i) {
			for(let j = 1;j < width - 1;++j) {
				hmap[i][j] = null;
			}
		}
		for(let i = 0;i < width;++i) {
			hmap[i][0] = hmap[i][width - 1];
			hmap[0][i] = hmap[width - 1][i];
		}

		fractal(hmap,0,width - 1,0,width - 1,50.0,decay);

		let xs = [];
		let ys = [];
		let zs = [];
		let uv = [];
	for(let i = 0;i < width;++i) {
		for(let j = 0;j < width;++j) {
				let rad = Math.pow(j < width / 2 ? j / width : (width - 1 - j) / (width - 1),0.25);
				rad = Math.sqrt(1 - Math.pow(j / (width - 1) * 2 - 1,2));
			xs.push((rad * hmap[i][j] + 1.0) * Math.cos(2 * Math.PI * i / (width - 1)));
			xs.push((rad * hmap[i][j] + 1.0) * Math.sin(2 * Math.PI * i / (width - 1)));
			xs.push(6 * len * (j / hmap[i].length - 0.5));

				zs.push(0,0,1);
			if(i > 0) if(i < width) if(j > 0) if(j < hmap[0].length) {
				ys.push(i * width + j);
				ys.push((i - 1) * width + j);
				ys.push((i - 1) * width + j - 1);
				ys.push((i - 1) * width + j - 1);
				ys.push(i * width + j - 1);
				ys.push(i * width + j);
			}
				uv.push(i / (width - 1),j / (width - 1));
		}
	}


	const geometry = new THREE.BufferGeometry();
				geometry.setIndex( ys );
	geometry.setAttribute( 'position', new THREE.Float32BufferAttribute(xs, 3 ) );
	geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute(uv, 2 ) );
	geometry.setAttribute( 'normal', new THREE.Float32BufferAttribute(zs, 3 ) );
			geometry.computeVertexNormals();
	return geometry;
}

				object = new THREE.Mesh(doener(50,0.55),material);
				object.position.set(0,0,0);
				object.scale.set(2,2,2);
				scene.add(object);
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				let de = renderer.domElement;
				de.style.width = "100%";
				document.getElementById("xyz").appendChild( de );

				stats = new Stats();
				document.getElementById("xyz").appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( 400, 400 );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			function render() {

				const timer = Date.now() * 0.0001;

				camera.position.x = Math.cos( timer ) * 800;
				camera.position.z = Math.sin( timer ) * 800;

				camera.lookAt( scene.position );

				scene.traverse( function ( object ) {

					if ( object.isMesh === true ) {

						object.rotation.x = timer * 5;
						object.rotation.y = timer * 2.5;

					}

				} );

				renderer.render( scene, camera );

			}

		</script>		
			
			
			
			
			
			
			
			
			
			
			
			
			
			</td>
			</tr>
			<tr>
			<td colspan=2>
				<iframe src="tarot.html" style="width:100%;height:350px"></iframe>
			</td>
			<td>
				<div style="overflow:auto;height:350px">
				<script>
					var chesses = [
						new ClassicChess(),
						new ZauberStrikeChess(),
						new GardenEdenChess(),
						new HalmaChess(),
						new GalagaChess(),
						new MonopolyChess(),
						new PersianRoulette()
					];

					chesses = shuffle(chesses);

					chesses.forEach(function(c) {
						document.write("<fieldset style='width:max-content;float:left'>");
						c.write();
						document.write("</fieldset>");
					});
				</script>
				</div>
				<script type="text/javascript" src="//counter.websiteout.net/js/22/4/0/0"></script>
			</td>
			
		</tr>
	</table>
<script>
	let w = 512;
	let h = 512;
	
    const gpu = new GPU();
    const tarot = new Tarot("reliable truth the day " + new Date());
    const kernel = gpu.createKernel(fractal).setOutput([w,h]).setGraphical(true);
    const cv = kernel.canvas;
    
    document.getElementById("xy").appendChild(cv);
    cv.style.width = "400px";
    cv.style.height = "400px";


    let cfg = [w,h,-5,5,5,-5];
    
    for(let i = 1;i <= 10;++i) {
        cfg.push(0);
        cfg.push(0);
    }
    
    cfg[6] = 0;
    cfg[7] = 0;
    cfg[8] = 0;
    cfg[9] = 0;
    cfg[10] = 1;
    cfg[11] = 0;
    
    cfg[16] = 1;
    cfg[17] = 0;
    
    kernel(cfg);
    
    window.setInterval(() => {
        for(let i = 1;i <= 5;++i) {
            cfg[6 + 2 * i] += 0.002 * i * (Math.random() - 0.5);
            cfg[6 + 2 * i + 1] += 0.002 * i * (Math.random() - 0.5);
        }
        kernel(cfg);
    },10);
        
    function speak() {
        var msg = new SpeechSynthesisUtterance();
        msg.text = tarot.get();
        msg.onend = speak;
        document.getElementById("ab").innerText = msg.text;
        window.speechSynthesis.speak(msg);
    }
    
    speak();

    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    var scale = new Array(12);
    
    function makeScale() {
	    let sc = [0,2,4,5,7,9,11];
	    let sc0 = [];
	    
	    for(let i = 0;i < sc.length - 1;++i) sc0.push(sc[i + 1] - sc[i]);
	    sc0.push(12 + sc[0] - sc[sc.length - 1]);
	    let m = Math.trunc(Math.random() * sc0.length);
	    console.log(sc0);
	    console.log(m);
	    
	    for(let i = 0;i < m;++i) {
		    let swp = sc0[0];
		    for(let j = 1;j < sc0.length;++j) sc0[j - 1] = sc0[j];
		    sc0[sc0.length - 1] = swp;
	    }
	    
	    sc = [0];
	    for(let j = 0;j < sc0.length - 1;++j) sc.push(sc0[j] + sc[j]);
	    
	    console.log(sc0);
	    console.log(sc);
	    
	    let n = -Math.round(Math.random() * 4);
	    
	    let k = 0;
	    for(let j = 0;j < 5;++j)
	    for(let i = 0;i < sc.length;++i) 
	    if(k < scale.length) {
		    scale[k] = sc[i] + 12 * j + n - 2;
		    k += 1;
	    }
	    
	    console.log(scale);
    }


    const add = gpu.createKernel(function (buffer,wave,offset,fr,channel,vol) {
        return buffer[this.thread.x + offset] + vol * wave[Math.trunc(this.thread.x / 2.0 * 4.0 * fr + channel)] / 128000;
    }).setOutput([22000]);
    
    class Instrument {
        constructor(arr) {
            this.wave = arr;
        }
        
        render(buffer,offset,tone,sampleRate,vol) {
    		const fr = Math.pow(2.0,tone / 12.0) * sampleRate / 44100.0;	
	        const n = Math.round(Math.random() * 50);
            const channels = 2;
            
            for(var channel = 0; channel < channels; channel++) {
                var nowBuffering = buffer.getChannelData(channel);
                var xs = add(nowBuffering,this.wave,offset + n,fr,channel,vol);
                for(let i = 0;i < xs.length;++i) 
                    if(i + offset + n < nowBuffering.length)
                        nowBuffering[i + offset + n] = xs[i];
	    	}	
        }
    }


    class Drum0 {
        constructor(instrument,q,d) {
            this.instrument = instrument;
            this.index = 0;
            this.q = q;
            this.d = d;
            console.log(q + " / " + d);
        }
        
        play(buffer,offset,tone,sampleRate) {
            if(this.index % this.q == this.d) {
                this.instrument.render(buffer,offset,tone,sampleRate,1.2);
            }
            this.index += 1;
        }
    }

    class Drum {
        constructor(instrument) {
            this.instrument = instrument;
        }
        
        play(buffer,offset,tone,sampleRate) {
            if(Math.random() < 0.4) {
                this.instrument.render(buffer,offset,tone,sampleRate,1.0);
            }
        }
    }

    class Melody {
        constructor(instrument) {
            this.instrument = instrument;
            this.tones = new Array(32);
            this.index = 0;
		    for(let i = 0;i < this.tones.length;++i) this.tones[i] = 0;		
    		this.tones[0] = scale.length * Math.random();
	    	this.tones[this.tones.length - 1] = scale.length * Math.random();
    		this.fractal(0,this.tones.length - 1,0.9,scale.length * (Math.random() < 0.5 ? 1.0 : -1.0));
		    let _min = 100000;
		    let _max = -100000;
		    for(let i = 0;i < this.tones.length;++i) if(this.tones[i] > _max) _max = this.tones[i];		
		    for(let i = 0;i < this.tones.length;++i) if(this.tones[i] < _min) _min = this.tones[i];	
		    for(let i = 0;i < this.tones.length;++i) this.tones[i] = Math.round((scale.length - 1) * (this.tones[i] - _min) / (_max - _min));
        }
        
        fractal(start,end,decay,amp) {
		    let m = Math.round((start + end) / 2);
		    if(this.tones[m] == 0) {
			    this.tones[m] = (this.tones[start] + this.tones[end]) / 2.0 + Math.random() * amp;
			    this.fractal(start,m,decay,-decay * amp);
			    this.fractal(m,end,decay,-decay * amp);
		    }
	    }

        play(buffer,offset,sampleRate) {
            if(Math.random() < 0.5) {
                this.instrument.render(buffer,offset,scale[this.tones[this.index]],sampleRate,1.0);
                if(Math.random() < 0.5) {
                    this.index += 1;
                    
                    if(this.index >= this.tones.length) {
                        this.index = 0;
                    }
                }
            }
        }
    }

    function rand(n) {
        return tarot.rnd() % n;
    }
    
    function sound() {
        makeScale();
        var channels = 2;
        var seconds = 60;
        var frameCount = audioCtx.sampleRate * seconds;
        var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);

        var drums0 = shuffle(drums);
        var instruments0 = shuffle(instruments);
        
        let ds = [];
        let takt = 4 + 2 * rand(3);
        let xs = [];
        for(let i = 0;i < 3;++i) {
            let m;
            do {
                m = rand(takt);
            } while(xs.includes(m));
            xs.push(m);
            ds.push(new Drum0(new Instrument(drums0.shift()),takt,m));
        }
        for(let i = 0;i < 2;++i) ds.push(new Drum(new Instrument(drums0.shift())));
        
        let ms = [];
        for(let i = 0;i < 2;++i) {
            ms.push(new Melody(new Instrument(instruments0.shift())));
        }
        
        for(let i = 0;i < frameCount;i += Math.round(audioCtx.sampleRate / 6)) {
            ds.forEach((d) => {
                d.play(myArrayBuffer,i,0,audioCtx.sampleRate);
            });
            ms.forEach((m) => {
                m.play(myArrayBuffer,i,audioCtx.sampleRate);
            });
        }
        
        // Get an AudioBufferSourceNode.
        // This is the AudioNode to use when we want to play an AudioBuffer
        var source = audioCtx.createBufferSource();
        source.onended = sound;
        // set the buffer in the AudioBufferSourceNode
        source.buffer = myArrayBuffer;
        // connect the AudioBufferSourceNode to the
        // destination so we can hear the sound
        source.connect(audioCtx.destination);
        // start the source playing
        source.start();
    }
    
    /*
    [drums,instruments].forEach((x) => {
        for(let j = 0;j < x.length;++j) {
		    let _min = 100000;
		    let _max = -100000;
		    for(let i = 0;i < x[j].length;++i) if(x[j][i] > _max) _max = x[j][i];		
		    for(let i = 0;i < x[j].length;++i) if(x[j][i] < _min) _min = x[j][i];	
		    for(let i = 0;i < x[j].length;++i) x[j][i] = Math.round(10000 * (x[j][i] - _min) / (_max - _min));
        }
    });
    */
    
    //makeScale();
    
    sound();
</script>



</body>
</html>

