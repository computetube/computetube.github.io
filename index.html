<html>
<head>
    <script src="gpu-browser.min.js"></script>
    <script src="MyLib.js"></script>
    <script src="ins.js"></script>
    <script src="drums.js"></script>
</head>
<body>
	<img src="const.png" style="position:fixed;bottom:0;right:0;z-index:10">
	<table style="width:100%;height:100%">
		<tr>
			<td id="xy" style="width:100%;">
				<div id="ab" style="position:fixed;top:20px;left:20px;font-size:20px;color:white;">HALLO</div>
			</td>
			<td>
				<div style="overflow:auto;height:500px">
				<script>
					var chesses = [
						new ClassicChess(),
						new ZauberStrikeChess(),
						new GardenEdenChess(),
						new HalmaChess(),
						new GalagaChess(),
						new MonopolyChess(),
						new PersianRoulette()
					];

					chesses = shuffle(chesses);

					chesses.forEach(function(c) {
						document.write("<fieldset style='width:max-content;float:left'>");
						c.write();
						document.write("</fieldset>");
					});
				</script>
				</div>
			</td>
		</tr>
	</table>
<script>
    const gpu = new GPU();
    const tarot = new Tarot("Joke of the day " + new Date());
    const kernel = gpu.createKernel(fractal).setOutput([512,512]).setGraphical(true);
    const cv = kernel.canvas;
    
    document.getElementById("xy").appendChild(cv);
    cv.style.width = "100%";
    cv.style.height = "100%";


    let cfg = [512,512,-5,5,5,-5];
    
    for(let i = 1;i <= 10;++i) {
        cfg.push(0);
        cfg.push(0);
    }
    
    cfg[6] = 0;
    cfg[7] = 0;
    cfg[8] = 0;
    cfg[9] = 0;
    cfg[10] = 1;
    cfg[11] = 0;
    
    cfg[16] = 1;
    cfg[17] = 0;
    
    kernel(cfg);
    
    window.setInterval(() => {
        for(let i = 1;i <= 5;++i) {
            cfg[6 + 2 * i] += 0.002 * i * (Math.random() - 0.5);
            cfg[6 + 2 * i + 1] += 0.002 * i * (Math.random() - 0.5);
        }
        kernel(cfg);
    },10);
        
    function speak() {
        var msg = new SpeechSynthesisUtterance();
        msg.text = tarot.get();
        msg.onend = speak;
        document.getElementById("ab").innerText = msg.text;
        window.speechSynthesis.speak(msg);
    }
    
    speak();

    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    var scale = new Array(12);
    
    function makeScale() {
	    let sc = [0,2,4,5,7,9,11];
	    let sc0 = new Array(sc.length);
	    
	    for(let i = 0;i < sc.length - 1;++i) sc0[i] = sc[i + 1] - sc[i];
	    sc0[sc.length - 1] = 12 + sc[0] - sc[sc.length - 1];
	    let m = Math.round(Math.random() * 12);
	    
	    for(let i = 0;i < m;++i) {
		    let swp = sc0[0];
		    for(let j = 1;j < sc.length;++j) sc0[j - 1] = sc0[j];
		    sc0[sc.length - 1] = swp;
	    }
	    for(let j = 1;j < sc.length;++j) sc[j] = sc0[j - 1] + sc[j - 1];
	    
	    console.log(sc0);
	    
	    let n = -Math.round(Math.random() * 4);
	    
	    let k = 0;
	    for(let j = 0;j < 5;++j)
	    for(let i = 0;i < sc.length;++i) 
	    if(k < scale.length) {
		    scale[k] = sc[i] + 12 * j + n - 2;
		    k += 1;
	    }
	    
	    console.log(scale);
    }


    const add = gpu.createKernel(function (buffer,wave,offset,fr,channel,vol) {
        return buffer[this.thread.x + offset] + vol * wave[Math.trunc(this.thread.x / 2.0 * 4.0 * fr + channel)] / 96000;
    }).setOutput([22000]);
    
    class Instrument {
        constructor(arr) {
            this.wave = arr[Math.round(Math.random() * (arr.length - 1))];
        }
        
        render(buffer,offset,tone,sampleRate,vol) {
    		const fr = Math.pow(2.0,tone / 12.0) * sampleRate / 44100.0;	
	        const n = Math.round(Math.random() * 200);
            const channels = 2;
            
            for(var channel = 0; channel < channels; channel++) {
                var nowBuffering = buffer.getChannelData(channel);
                var xs = add(nowBuffering,this.wave,offset + n,fr,channel,vol);
                for(let i = 0;i < xs.length;++i) 
                    if(i + offset + n < nowBuffering.length)
                        nowBuffering[i + offset + n] = xs[i];
	    	}	
        }
    }


    class Drum {
        constructor(instrument) {
            this.instrument = instrument;
        }
        
        play(buffer,offset,tone,sampleRate) {
            if(Math.random() < 0.4) {
                this.instrument.render(buffer,offset,tone,sampleRate,1.6);
            }
        }
    }

    class Melody {
        constructor(instrument) {
            this.instrument = instrument;
            this.tones = new Array(32);
            this.index = 0;
		    for(let i = 0;i < this.tones.length;++i) this.tones[i] = 0;		
    		this.tones[0] = scale.length * Math.random();
	    	this.tones[this.tones.length - 1] = scale.length * Math.random();
    		this.fractal(0,this.tones.length - 1,0.9,scale.length * (Math.random() < 0.5 ? 1.0 : -1.0));
		    let _min = 100000;
		    let _max = -100000;
		    for(let i = 0;i < this.tones.length;++i) if(this.tones[i] > _max) _max = this.tones[i];		
		    for(let i = 0;i < this.tones.length;++i) if(this.tones[i] < _min) _min = this.tones[i];	
		    for(let i = 0;i < this.tones.length;++i) this.tones[i] = Math.round((scale.length - 1) * (this.tones[i] - _min) / (_max - _min));
        }
        
        fractal(start,end,decay,amp) {
		    let m = Math.round((start + end) / 2);
		    if(this.tones[m] == 0) {
			    this.tones[m] = (this.tones[start] + this.tones[end]) / 2.0 + Math.random() * amp;
			    this.fractal(start,m,decay,-decay * amp);
			    this.fractal(m,end,decay,-decay * amp);
		    }
	    }

        play(buffer,offset,sampleRate) {
            if(Math.random() < 0.7) {
                this.instrument.render(buffer,offset,scale[this.tones[this.index]],sampleRate,1.0);
                if(Math.random() < 0.7) {
                    this.index += 1;
                    
                    if(this.index >= this.tones.length) {
                        this.index = 0;
                    }
                }
            }
        }
    }

    function sound() {
        makeScale();
        var channels = 2;
        var seconds = 60;
        var frameCount = audioCtx.sampleRate * seconds;
        var myArrayBuffer = audioCtx.createBuffer(channels, frameCount, audioCtx.sampleRate);

        let ds = [];
        for(let i = 0;i < 3;++i) {
            ds.push(new Drum(new Instrument(drums)));
        }
        
        let ms = [];
        for(let i = 0;i < 2;++i) {
            ms.push(new Melody(new Instrument(instruments)));
        }
        
        for(let i = 0;i < frameCount;i += Math.round(audioCtx.sampleRate / 6)) {
            ds.forEach(async (d) => {
                d.play(myArrayBuffer,i,0,audioCtx.sampleRate);
            });
            ms.forEach(async (m) => {
                m.play(myArrayBuffer,i,audioCtx.sampleRate);
            });
        }
        
        // Get an AudioBufferSourceNode.
        // This is the AudioNode to use when we want to play an AudioBuffer
        var source = audioCtx.createBufferSource();
        source.onended = sound;
        // set the buffer in the AudioBufferSourceNode
        source.buffer = myArrayBuffer;
        // connect the AudioBufferSourceNode to the
        // destination so we can hear the sound
        source.connect(audioCtx.destination);
        // start the source playing
        source.start();
    }
    
    [drums,instruments].forEach((x) => {
        for(let j = 0;j < x.length;++j) {
		    let _min = 100000;
		    let _max = -100000;
		    for(let i = 0;i < x[j].length;++i) if(x[j][i] > _max) _max = x[j][i];		
		    for(let i = 0;i < x[j].length;++i) if(x[j][i] < _min) _min = x[j][i];	
		    for(let i = 0;i < x[j].length;++i) x[j][i] = Math.round(10000 * (x[j][i] - _min) / (_max - _min));
        }
    });
    
    sound();
</script>
</body>
</html>

